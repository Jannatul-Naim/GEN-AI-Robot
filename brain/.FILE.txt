vision/
â”‚
â”œâ”€â”€ main.py                
â”œâ”€â”€ brain.py              
â”œâ”€â”€ llm.py            
â”œâ”€â”€ memory.py              
â”œâ”€â”€ server.py   
â”œâ”€â”€ config.py 
â”œâ”€â”€ plan.py              
â”œâ”€â”€ __init__.py
â””â”€â”€ .FILE.txt




REQUIREMENTS : requests
               



Model : 


âš™ï¸ config.py



RUSSPARRY_URL = "http://10.237.216.204:9000/robot"
VISION_URL = "http://localhost:9100/vision"
OLLAMA_URL = "http://localhost:11434/api/v1/llm/brain"
MIN_CONFIDENCE = 0.6
MAX_TOKENS = 1000
TEMPERATURE = 0.2



ðŸ§  brain.py

from plan import Planner
from memory import RobotMemory
from llm import LLM


class Brain:
    def __init__(self):
        self.memory = RobotMemory()
        self.planner = Planner()
        self.llm = LLM()

    def process(self, cmd, vision):
        if self.memory.safety_state == "stop":
            return {"intent": "stop", "plan": [], "reply": "Stopped"}

        objects = vision.get("objects", [])
        decision = self.llm.decide(cmd, objects, self.memory.snapshot())

        if not decision:
            return {"intent": "chat", "plan": [], "reply": "I did not understand"}

        if decision["intent"] == "stop":
            self.memory.stop()
            return {"intent": "stop", "plan": [], "reply": "Stopping"}

        if decision["intent"] == "chat":
            return {"intent": "chat", "plan": [], "reply": decision.get("reply", "")}

        plan = []

        for step in decision.get("steps", []):
            if step["action"] == "pick":
                if self.memory.holding:
                    return {"intent": "chat", "plan": [], "reply": "Already holding"}
                obj = self.planner.find(
                    step.get("target"),
                    objects,
                    mode=step.get("mode")
                )
                if not obj:
                    return {"intent": "chat", "plan": [], "reply": "Object not visible"}
                plan.append(self.planner.pick(obj))
                self.memory.holding = obj["name"]

            elif step["action"] == "place":
                if not self.memory.holding:
                    return {"intent": "chat", "plan": [], "reply": "Nothing to place"}
                relation = step.get("relation")
                if relation == "left":
                    x = -10
                    z = 25
                elif relation == "right":
                    x = 10
                    z = 25
                else:
                    x = 0
                    z = 25
                plan.append(self.planner.place(x, z))
                self.memory.holding = None

            elif step["action"] == "give":
                if not self.memory.holding:
                    return {"intent": "chat", "plan": [], "reply": "Nothing to give"}
                plan.append(self.planner.give())
                self.memory.holding = None

        return {"intent": "task", "plan": plan, "reply": decision.get("reply", "")}


ÖŽ llm.py
import json
import requests
import re
import config


class LLM:
    def extract(self, text):
        try:
            m = re.search(r"\{[\s\S]*\}", text)
            if not m:
                return None
            return json.loads(m.group(0))
        except:
            return None

    def prompt(self, cmd, objects, memory):
        return f"""
You control a REAL robot arm.

X AXIS:
negative = left
positive = right

Z AXIS:
front = 25

RULES:
- Use only visible objects
- Never invent objects
- Max 2 steps
- If unsafe or unclear -> chat
- If multiple objects exist, resolve far / nearest
- If place without reference -> place front (z=25)
- Output JSON ONLY

VISIBLE OBJECTS:
{json.dumps(objects)}

MEMORY:
{json.dumps(memory)}

FORMAT:
{{
  "intent": "task|chat|stop",
  "steps": [
    {{
      "action": "pick|place|give",
      "target": string|null,
      "mode": "farthest|nearest|null",
      "relation": "left|right|front|null",
      "reference": string|null
    }}
  ],
  "reply": "short"
}}

COMMAND:
{cmd}
"""

    def decide(self, cmd, objects, memory):
        r = requests.post(
            config.OLLAMA_URL,
            json={
                "model": config.OLLAMA_MODEL,
                "prompt": self.prompt(cmd, objects, memory),
                "stream": False,
                "options": {"temperature": 0}
            },
            timeout=config.LLM_TIMEOUT
        )
        return self.extract(r.json().get("response", ""))


ðŸ’¾ memory.py
class RobotMemory:
    def __init__(self):
        self.holding = None
        self.safety_state = "normal"

    def snapshot(self):
        return {
            "holding": self.holding,
            "safety_state": self.safety_state
        }

    def stop(self):
        self.safety_state = "stop"

    def reset(self):
        self.holding = None
        self.safety_state = "normal"


ðŸŒ server.py
import requests
import json
import config


def get_vision():
    try:
        r = requests.get(config.VISION_URL, timeout=1)
        return r.json()
    except requests.exceptions.RequestException:
        return {"objects": []}
    

def send_to_russparry(plan):
    if not plan:
        return
    print(json.dumps({"plan": plan}, indent=2))
    try:
        requests.post(
            config.RUSSPARRY_URL,
            json={"plan": plan},
            timeout=30
        )
    except requests.exceptions.ConnectTimeout:
        print("âŒ Russparry timeout: server unreachable")
    except requests.exceptions.ConnectionError:
        print("âŒ Russparry connection error")

ðŸŽ¯ plan.py
import config


class Planner:
    def find(self, name, objects, mode=None):
        candidates = [
            o for o in objects
            if o.get("name") == name and o.get("confidence", 0) >= config.MIN_CONFIDENCE
        ]
        if not candidates:
            return None
        if mode == "farthest":
            return max(candidates, key=lambda o: o.get("z_cm", 0))
        if mode == "nearest":
            return min(candidates, key=lambda o: o.get("z_cm", 0))
        return candidates[0]

    def pick(self, obj):
        return {
            "action": "pick",
            "object": obj["name"]
        }

    def place(self, x, z):
        return {
            "action": "place",
            "x": x,
            "z": z
        }

    def give(self):
        return {
            "action": "give"
        }



ðŸš€ main.py
import time
import json

from brain import Brain
from server import send_to_russparry, get_vision


def main():
    brain = Brain()

    print("ðŸ§  Brain online. Type commands (or 'quit').")

    while True:
        try:
            user_text = input("\nUSER> ").strip()
            if not user_text:
                continue

            if user_text.lower() in ("quit", "exit"):
                print("Shutting down brain.")
                break

            vision = get_vision()
            print("Vision data:", vision)

            result = brain.process(user_text, vision)

            print("\nBRAIN OUTPUT:")
            print(json.dumps(result, indent=2))

            if result.get("plan"):
                send_to_russparry(result["plan"])

        except KeyboardInterrupt:
            print("\nInterrupted. Exiting.")
            break

        except Exception as e:
            print("[BRAIN ERROR]:", e)
            time.sleep(0.5)


if __name__ == "__main__":
    main()

